AUTENTICAZIONE

Vediamo come funzione un login
il login viene creato con un form pke l utente dovra inserire i propri dati e il form e' il modo per interagire con esso.
il form avra' come action="/password-check"
Il controller riceve i dati della view (username e password), li controlla e decide se sono corretti oppure no
Le informazioni contenute nel form vengono inviate in POST alla pagina /password-check. Non vengono inviate in GET pke se no possono essere accessibiti a tutti
Ovviamente le password che sono la parte piu sensibile dei nostri dati non vengono inviati in maniera diretta in reta senza una protezione.
Per questo si utilizzano le funzioni di HASHING. Le funzioni di hashing sono delle funzioni non invertibili(la stringa di hashing che viene generata non potra essere usate per ottere il processo inverso cioe' la nostra password) che trasformano una stringa di lunghezza arbitraria in una stringa di lunghezza prefissata.(criptando la nostra password)

HASHING FUNCTION
ad ogni testo di input corrisponde uno e uno solo output(hash). Indipendentemente dalla lunghezza della password che noi inseriamo l output(hash) avra' sempre una lunghezza ben definita
le funzioni piu' di hashing piu' usate sono SHA, MD5, BCRYPY.

quindi il DB sotto banco che cosa fa? 
l utente reinserisce la password, il db con la funzione di hashing genera nuova la sua stringa, confronta la stringa generata con quella che lui ha memorizzato in precedente e se coincidono allora si puo' accedere in caso contrario no.

le funzioni hashing le possiamo usare anche tramite JS (vedi slide 620 Laravel-Authentication)

Rainbow Tables e' un sito che detiene tutte le stringhe hashing delle password piu' comuni

Quando il db salva la stringa hashing non e' una ottima soluzione pke si puo' applicare il processo inverso cioe' passare dalla stringa hashing alla password vera e propria.
Quindi per proteggersi da questo procedimento inverso si usano i SALT (ne esistono molti altri).
Il salt che anch'essa una stringa hash generata in maniera casuale dal nostro db che si aggancera' alla nostra stringa hash per avere una maggiore protezione.

la password memorizzata nel DB sara': hash(password_plaintext + salt)

Attenzione che se i siti ci rimandamo in maniera chiara e leggibile la nostra password vuol dire che non e' un sito sicuro pke non stanno proteggendo la password.

E una volta autenticato?
Una volta autenticato, come fa il server a ricordarsi che l’utente si è autenticato correttamente?
Con due strumenti, cookie e sessioni:
- Il cookie è un pezzo di informazione che rimane sul browser dell’utente; (salvano i dati per un breve periodo)
- La sessione è una informazione che rimane salvata sul server; (simile alla session generata nell esercizio delle crud completo)
Se c’è un cookie che contiene un identificativo (token) che corrisponde ad una sessione salvata sul server,
allora l’utente è autenticato.

Laravel Magic
Con Laravel, tutta questa complessità è già gestita e pronta da utilizzare e ciò è un bene:
l’implementazione di codice che gestisce autenticazione e più in generale, sicurezza, è
estremamente critico, basta una piccola distrazione per creare bug e consentire accessi indesiderati.
Sfruttare il codice scritto da esperti, e visto e rivisto da vari occhi ci dà un grande sicurezza sul fatto
che il codice sia sicuro, testato ad affidabile.
Potreste dire lo stesso del vostro codice?

Laravel Magic
Laravel gestisce/fornisce:
- Una pagina di login
- Una tabella utenti
- Tutti i controller necessari per fare login, logout, registrazione della password, reset password
- Tutto il sistema di gestione delle sessioni per verificare se un utente è autenticato, sia nel controller che direttamente in Blade

laravel ci da un pacchettino extra di autentificazione ' composer require laravel/ui:^2.4'
con questo verifichiamo dei cambiamenti nel package.json
Con questo pacchetto noi non gestiremo la logica dei dati e nella loro riservatezza

Serve a gestire la parte fron-end per la gestione dei dati vedendo la documentazione possiamo gestire tante cose come bootstrap/vue ecc.. (leggere la documentazione)

php artisan ui vue --auth (vediamo come interagisce vue con laravel), seguiamo la procedura che ci dice il terminale di fare npm install && npm run dev
ci andra' a scaricare la versione bootstrap 4.0 quindi occhio alla documentazione di bootstrap
ci ha creato i file di sass variables.scss , in app.scss ha importato le librerie con i rispettivi collegamenti
in view ci ha creato i due file di home.blade.php e welcome.blade.php , una cartella layout, la cartella auth (gestira' la parte del login) al suo interno la cartella password( con tutti i file che ci servono per la registrazione dei dati e la loro sicurezza)


nel cartella Controller abbiamo un altra cartella auth( con tutti controller inerenti)

web.php abbiamo una rotta della homeController e le rotte della autentificazione con Auth       php artisan route:list possiamo vedere tutte le rotte di Auth

facciamo la migration delle rotte

avviando la pagina possiamo notare il login e il register che sono stati aggiunti alla solita pagina di laravel


Nella barra del browser quando facciamo ispeziona pagina abbiamo una sezione Application, e nello storage abbiamo tutti i cookies che vengono rappresentati per Dominio


Laravel Authentication
Dopo il login, Laravel di default reindirizza gli utenti alla rotta /home.
Noi però vogliamo individuare l'area di amministrazione utilizzando il prefisso /admin per tutte le pagine di backoffice.
Possiamo modificare la path nel file app/Providers/RouteServiceProvider.php


Nel cartella controller creiamo una sottocartella Admin con una sua HomeController.php per gestire la parte privata del loggato,
mentre nel HomeController.php che fa riferimento alla parte pubblica del sito possiamo anche rimuovere la funzione del middleware('auth') pke non ne ha bisogno del controllo


Creazione della tabella del Db con la rispettiva creazione della migration

Creazione delle rotte per la CRUD   php artisan make:controller Admin/PostController --resource
1) Creazione del file index.blade.php
    creazione della tabella per i posto
    creazione link per il singolo post
    creazione di due post fittizzi sul DB

    in Models/Post.php importo la libreria Carbon che ci servira' per le date
    modifichiamo la visuallizzazione della data in index
2)Show  creazione del file
    creaiamo un post con un minimo di html
    creiamo anche la rotta per show

Come usare Vue (single page application)
apriamo la home e creaiamo con collegamento con vue con id=root
Front-office
Per la parte di front-office vogliamo utilizzare Vue con i suoi componenti. Ciò che dobbiamo fare è aggiungere alla fine del file web.php una rotta di fallback che va a
mappare tutte le rotte non intercettate nelle istruzioni precedenti. Questa rotta viene gestita con una semplice closure che restituisce una view.

In sostanza separare le rotte che si gestira' admin e auth che sono quelle protette con quelle che si dovra gestire la home che sono quelle pubbliche oppure tutto quello che non sappiamo deve arrivare a Vue


La view guest/home.blade.php corrisponde allo scheletro html di tutto il front-office con i collegamenti al foglio di stile e al file javascript.
Il suo contenuto però è vuoto: all'interno del tag body c'è solamente un div in cui poi si inserirà Vue.

Inserisco il link del css all interno del file guest/home.blade.php
nella cartella resource/js creo un nuovo file e modifico anche il contenuto che non mi serve in app.js
in webpack.mix.js aggiungo il nuovo file che ho creato nella cartella resource/js
Rinomino il file all interno resource/js/components in App e inizio a inserire tutti i dati di Vue
npm run dev     per caricare il file aggiunto in js

In questo modo e' possibile separare i due file, app.js possiamo usarlo per la parte back-end mentre il front.js possiamo usarla per la parte front-end


SEEDERS
Come creare i file Seeders per popolare le tabelle del DB
Possiamo creare tanti seeder quante sono le tabelle usando il comando artisan. php artisan make:seeder UsersTableSeeder      //nota bene che Seeder e' al sigolare e' una classe
Una volta creato un seeder lor troveremo nella cartella database/seeds.
La classe Seeder contiene un metodo run() che viene eseguito ogni volta che il file viene chiamato.
In questo metodo possiamo inserire la logica per aggiungere i dati al nostro DB.

all interno della funzione run() gli importiamo sia Post e sia Str pke ci serviranno per la creazione delle tupla della tabella
Prendiamo un array associativo con i dati al suo interno simili all organizzazione del DB
tramite un foreach creiamo un post per ogni singolo elemento dell array in modo da riempire la tabella

Per lanciare il nostro seeder dobbiamo usare un comando  php artisan db:seed --class=PostTableSeeder

nella cartella Seed abbiamo anche un altro file generato che si chiama DatabaseSeeder.php questo file serve sopratutto per le applicazioni piu' grosse
dove altre a passare dei semplici post si necessita di passare altre informazioni come gli utenti, i team ecc.. Quindi invece di riscrivere il solito comando nel terminale, tramite la sua funzione all interno del file 
sbloccare la chiamata che fa al PostTableSeeder.php , e trasformarlo in un array di chiamate dei seeder per poi fare un unica chiamata.


php artisan migrate:refresh --seed      ci permette di fare diversi passaggi: migrate, refresh (cancella tutte le migrazioni e le rilancia), seed (lancia le seed //occhio che per funzione la chiamata delle seeder deve provenire dal dB principale)

Fakers
Possiamo quindi creare dei seeders per popolare le nostre tabelle con dei dati utili alla nostra applicazione. Ma a volte sarà necessario dover aggiungere, semplicemente per sviluppare la nostra
applicazione, dei dati fake che serviranno per emulare ciò che sarà effettivamente la nostra applicazione, una volta in produzione.
Es. vogliamo inserire 100 post finti dentro al blog che stiamo creando, ognuno con dati finti ma plausibili (es. date, titoli, autori, etc..)
per la creazione di post finti lanciare questo per rimuovere quello vecchio composer remove fzaninotto/faker , lanciare questo comando composer require fakerphp/faker per quello nuovo

Per creare i post finti dobbiamo cancellare quelli vecchi e dopo importare la classe faker nella cartella seeds










